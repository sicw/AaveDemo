pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol";
import "../lendingpool/LendingPoolCore.sol";
import "../configuration/LendingPoolAddressesProvider.sol";

/**
 * @title Aave ERC20 AToken
 *
 * @dev Implementation of the interest bearing token for the DLP protocol.
 * @author Aave
 */
contract AToken is ERC20, ERC20Detailed {

    using WadRayMath for uint256;

    uint256 public constant UINT_MAX_VALUE = uint256(-1);

    address public underlyingAssetAddress;
    LendingPoolAddressesProvider private addressesProvider;
    LendingPoolCore private core;

    // 'userIndexes' 是指用户在借贷市场上的利息指数。每个用户都有一个自己的利息指数，该指数会随着时间的推移而变化。用户的利息指数反映了他们在市场上的借款和还款历史记录，以及当前的借贷利率。这个指数用于计算用户需要支付的利息和可获得的收益。
    mapping(address => uint256) private userIndexes;

    // 这些地址是由协议管理员指定的。如果一个用户的地址出现在这个列表中，那么他们在借贷市场上获得的利息将被重定向到列表中的另一个地址，而不是直接发送到用户的地址。这个功能可以用来实现一些特殊的应用场景，例如将利息发送到代币合约地址以进行自动化交易等。注意，这个功能只在协议管理员指定的地址列表中的用户之间有效，其他用户仍然会按照正常的方式获得他们应该获得的利息。
    mapping(address => address) private interestRedirectionAddresses;

    // 与上面收益配合使用, 别人把收益重定向给我了, 我这里是重定向余额
    mapping(address => uint256) private redirectedBalances;

    mapping(address => address) private interestRedirectionAllowances;

    constructor(
        LendingPoolAddressesProvider _addressesProvider,
        address _underlyingAsset,
        uint8 _underlyingAssetDecimals,
        string memory _name,
        string memory _symbol
    ) public ERC20Detailed(_name, _symbol, _underlyingAssetDecimals) {
        addressesProvider = _addressesProvider;
        core = LendingPoolCore(addressesProvider.getLendingPoolCore());
        underlyingAssetAddress = _underlyingAsset;
    }

    /**
    * 计算用户的余额, 即 本金余额 + 本金余额生成的利息 + 重定向余额生成的利息
    * @dev calculates the balance of the user, which is the
    * principal balance + interest generated by the principal balance + interest generated by the redirected balance
    * @param _user the user for which the balance is being calculated
    * @return the total balance of the user
    **/
    function balanceOf(address _user) public view returns (uint256) {

        // 用户当前本金余额
        //current principal balance of the user
        uint256 currentPrincipalBalance = super.balanceOf(_user);

        //balance redirected by other users to _user for interest rate accrual
        uint256 redirectedBalance = redirectedBalances[_user];

        if (currentPrincipalBalance == 0 && redirectedBalance == 0) {
            return 0;
        }

        // 如果_user没有将利息重定向给任何人，则为自己积累利息
        //if the _user is not redirecting the interest to anybody, accrues
        //the interest for himself

        if (interestRedirectionAddresses[_user] == address(0)) {
            // 算本金+重定向余额
            //accruing for himself means that both the principal balance and
            //the redirected balance partecipate in the interest
            return calculateCumulatedBalanceInternal(
                _user,
                currentPrincipalBalance.add(redirectedBalance)
            )
            .sub(redirectedBalance);
        }
        else {
            // 只有重定向余额
            //if the user redirected the interest, then only the redirected
            //balance generates interest. In that case, the interest generated
            //by the redirected balance is added to the current principal balance.
            return currentPrincipalBalance.add(
                calculateCumulatedBalanceInternal(
                    _user,
                    redirectedBalance
                )
                .sub(redirectedBalance)
            );
        }
    }

    /**
    * @dev calculate the interest accrued by _user on a specific balance
    * @param _user the address of the user for which the interest is being accumulated
    * 计算利息的余额计算利息的余额
    * @param _balance the balance on which the interest is calculated
    * @return the interest rate accrued
    **/
    function calculateCumulatedBalanceInternal(
        address _user,
        uint256 _balance
    ) internal view returns (uint256) {
        // wad 18 bit精度的数
        // ray 27 bit精度的数
        // 这段时间的本金+收益
        return _balance
        .wadToRay()
        .rayMul(core.getReserveNormalizedIncome(underlyingAssetAddress))
        .rayDiv(userIndexes[_user])
        .rayToWad();
    }

    /**
    * @dev accumulates the accrued interest of the user to the principal balance
    * @param _user the address of the user for which the interest is being accumulated
    * @return the previous principal balance, the new principal balance, the balance increase
    * and the new user index
    **/
    function cumulateBalanceInternal(address _user)
    internal
    returns(uint256, uint256, uint256, uint256) {

        // 本金
        uint256 previousPrincipalBalance = super.balanceOf(_user);

        // 计算上次累计以来的应计利息
        //calculate the accrued interest since the last accumulation
        uint256 balanceIncrease = balanceOf(_user).sub(previousPrincipalBalance);

        // 铸造与累积数量相等的代币 (铸造从上次更新到现在产生的利息)
        //mints an amount of tokens equivalent to the amount accumulated
        _mint(_user, balanceIncrease);

        // 更新用户索引(刚才有除法的步骤)
        //updates the user index
        uint256 index = userIndexes[_user] = core.getReserveNormalizedIncome(underlyingAssetAddress);
        return (
        previousPrincipalBalance,
        previousPrincipalBalance.add(balanceIncrease),
        balanceIncrease,
        index
        );
    }

    /**
    * @dev updates the redirected balance of the user. If the user is not redirecting his
    * interest, nothing is executed.
    * @param _user the address of the user for which the interest is being accumulated
    * @param _balanceToAdd the amount to add to the redirected balance
    * @param _balanceToRemove the amount to remove from the redirected balance
    **/
    function updateRedirectedBalanceOfRedirectionAddressInternal(
        address _user,
        uint256 _balanceToAdd,
        uint256 _balanceToRemove
    ) internal {

        address redirectionAddress = interestRedirectionAddresses[_user];
        //if there isn't any redirection, nothing to be done
        if (redirectionAddress == address(0)) {
            return;
        }

        //compound balances of the redirected address
        (,,uint256 balanceIncrease, uint256 index) = cumulateBalanceInternal(redirectionAddress);

        //updating the redirected balance
        redirectedBalances[redirectionAddress] = redirectedBalances[redirectionAddress]
        .add(_balanceToAdd)
        .sub(_balanceToRemove);

        // 如果重定向地址的利息也被重定向了，我们需要通过添加余额增加来更新重定向目标的重定向余额。换句话说，这段代码用于处理当一个地址的利息被重定向到另一个地址时，需要更新另一个地址的重定向余额。
        //if the interest of redirectionAddress is also being redirected, we need to update
        //the redirected balance of the redirection target by adding the balance increase
        address targetOfRedirectionAddress = interestRedirectionAddresses[redirectionAddress];

        if (targetOfRedirectionAddress != address(0)) {
            redirectedBalances[targetOfRedirectionAddress] = redirectedBalances[targetOfRedirectionAddress].add(balanceIncrease);
        }
    }

    /**
     * @dev mints token in the event of users depositing the underlying asset into the lending pool
     * only lending pools can call this function
     * @param _account the address receiving the minted tokens
     * @param _amount the amount of tokens to mint
     */
    function mintOnDeposit(address _account, uint256 _amount) external {

        //cumulates the balance of the user
        (,
        ,
        uint256 balanceIncrease,
        uint256 index) = cumulateBalanceInternal(_account);

        // 如果用户将其利息重定向到其他人，我们将通过将应计利息和存款金额相加来更新重定向地址的重定向余额。换句话说，这段代码用于处理用户将其存款的利息重定向到其他地址的情况。
        //if the user is redirecting his interest towards someone else,
        //we update the redirected balance of the redirection address by adding the accrued interest
        //and the amount deposited
        updateRedirectedBalanceOfRedirectionAddressInternal(_account, balanceIncrease.add(_amount), 0);

        //mint an equivalent amount of tokens to cover the new deposit
        _mint(_account, _amount);
    }
}
